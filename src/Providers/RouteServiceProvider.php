<?php

namespace App\Providers;

use Core\Routing\RouteRegistrar;
use Core\Support\ServiceProvider;

class RouteServiceProvider extends ServiceProvider
{
    /**
     * Register any routes for your application.
     *
     * @return void
     */
    public function register(): void
    {
        // Register the provider itself so it can be injected into other services like commands.
        // We wrap it in a closure to ensure the DI container correctly handles it
        // as a factory, even though we are returning the existing instance.
        // This avoids reflection issues with pre-existing objects.
        $this->app->singleton(static::class, fn () => $this);

        $this->app->singleton(\Core\Routing\Router::class, function ($app) {
            return new \Core\Routing\Router($app);
        });

        // Đăng ký RouteRegistrar một cách tường minh.
        // Điều này giúp DI container biết cách khởi tạo nó và làm cho dependency rõ ràng hơn.
        $this->app->singleton(RouteRegistrar::class);

        // Register the Redirector for creating redirect responses.
        $this->app->singleton(\Core\Http\Redirector::class, function ($app) {
            return new \Core\Http\Redirector($app);
        });

        $this->registerCommands();
    }

    public function boot(): void
    {
        $router = $this->app->make(\Core\Routing\Router::class);

        // In production, load the cached routes file for maximum performance.
        // This file is generated by the `route:cache` command.
        $cachedRoutesFile = $this->app->getCachedRoutesPath();
        if (file_exists($cachedRoutesFile) && !env('APP_DEBUG', false)) {
            $cachedRoutes = require $cachedRoutesFile;
            $router->loadFromCache($cachedRoutes);
            return;
        }

        $this->mapRoutes($router);
    }

    /**
     * Load all routes for the purpose of caching.
     * This method is called by the `route:cache` command.
     */
    public function loadRoutesForCaching(\Core\Routing\Router $router): void
    {
        $this->mapRoutes($router);
    }

    /**
     * Define the routes for the application.
     * This is the single source of truth for all route registrations.
     */
    protected function mapRoutes(\Core\Routing\Router $router): void
    {
        // 1. Register all routes defined by attributes in the application and modules.
        $this->mapAttributeRoutes($router);

        // 2. Register other manual/global routes that are not component-based.
        $router->post('/bault/upload-file', [\Http\Controllers\ComponentUploadController::class, '__invoke']);
        $router->post('/bault/update', [\Http\Controllers\ComponentController::class, '__invoke']);
    }

    /**
     * Scan all relevant directories and register routes defined by attributes.
     * This is the single source for attribute-based routing.
     */
    protected function mapAttributeRoutes(\Core\Routing\Router $router): void
    {
        $registrar = $this->app->make(RouteRegistrar::class);
        $paths = $this->getRouteAttributePaths();

        if (!empty($paths)) {
            $registrar->registerRoutes($router, $paths);
        }
    }

    /**
     * Get all paths where controllers with route attributes might be located.
     *
     * @return string[]
     */
    protected function getRouteAttributePaths(): array
    {
        $normalize = fn (string $path): string => str_replace(['/', '\\'], DIRECTORY_SEPARATOR, $path);

        $pathsToScan = [];

        // 1. Add the core application's top-level controller path.
        // The RouteRegistrar is responsible for scanning this path recursively.
        $coreControllerPath = $normalize(base_path('src/Http/Controllers'));
        if (is_dir($coreControllerPath)) {
            $pathsToScan[] = $coreControllerPath;
        }

        // 2. Add the top-level controller paths from all modules.
        // The RouteRegistrar will handle the recursive scanning within each of these.
        $moduleControllerPaths = glob($normalize(base_path('Modules/*/Http/Controllers')), GLOB_ONLYDIR);
        if ($moduleControllerPaths) {
            $pathsToScan = array_merge($pathsToScan, $moduleControllerPaths);
        }

        // Return a clean list of top-level directories to be scanned.
        return $pathsToScan;
    }
    /**
     * Register the route caching commands.
     */
    protected function registerCommands(): void
    {
        if ($this->app->runningInConsole()) {
            $commands = [
                \Core\Console\Commands\RouteCacheCommand::class,
                \Core\Console\Commands\RouteClearCommand::class,
                \Core\Console\Commands\RouteListCommand::class, // Thêm dòng này
                \Core\Console\Commands\PerformanceTestCommand::class,
            ];

            foreach ($commands as $commandClass) {
                // Chỉ đăng ký nếu class command thực sự tồn tại.
                // Điều này giúp ứng dụng không bị lỗi nếu một file command bị xóa.
                if (class_exists($commandClass)) {
                    // Sử dụng singleton để đảm bảo command chỉ được khởi tạo một lần.
                    // Container sẽ tự động "sử dụng lại" instance đã có.
                    $this->app->singleton($commandClass);

                    // Tag command để Kernel của console có thể tìm thấy và nạp vào.
                    $this->app->tag($commandClass, 'console.command');
                }
            }
        }
    }
}
